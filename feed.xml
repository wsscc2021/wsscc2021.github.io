<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://wsscc2021.github.io/</id><title>D.G.Lee</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2021-10-27T16:14:30+09:00</updated> <author> <name>wsscc2021</name> <uri>https://wsscc2021.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://wsscc2021.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://wsscc2021.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2021 wsscc2021 </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Kubernetes - Cluster Autoscaler + OverProvisioning</title><link href="https://wsscc2021.github.io/posts/Kubernetes-Cluster-Autoscaler-+-OverProvisioning/" rel="alternate" type="text/html" title="Kubernetes - Cluster Autoscaler + OverProvisioning" /><published>2021-10-27T15:00:00+09:00</published> <updated>2021-10-27T15:00:00+09:00</updated> <id>https://wsscc2021.github.io/posts/Kubernetes-Cluster-Autoscaler-+-OverProvisioning/</id> <content src="https://wsscc2021.github.io/posts/Kubernetes-Cluster-Autoscaler-+-OverProvisioning/" /> <author> <name>D.G.Lee</name> </author> <category term="DevOps" /> <summary> 컨테이너 생성 시간 vs VM 생성 시간 컨테이너는 VM보다 경량적인 isolation 기술로써, VM보다 이미지 크기가 작고 빠르게 프로비저닝되는 장점을 가지고 있습니다. 이는 분산 시스템 형태에서 수평적 확장을 수행하는 클라우드 환경에서 더욱 부각됩니다. 때문에 일반적으로 클라우드 환경에서는 클라우드 업체에서 제공해주는 VM 위에서 경량의 컨테이너를 오케스트레이션하는 방식으로 운영하게 되는 데, 대략적으로 아래와 같은 구성을 가집니다. (확장 시 VM이 아닌 컨테이너만 생성하여 빠르게 확장합니다.) Cluster Autoscaler 위에서 살펴본 것처럼 노드(VM) 위에서 컨테이너를 실행함으로써 프로비저닝 시간을 단축하여 확장의 성능 측면에서 장점을 가질 수 있습니다. 하지만 VM... </summary> </entry> <entry><title>Kubernetes - Pod 불균형 없애고 가용성 높이기</title><link href="https://wsscc2021.github.io/posts/Kubernetes-Pod-%EB%B6%88%EA%B7%A0%ED%98%95-%EC%97%86%EC%95%A0%EA%B3%A0-%EA%B0%80%EC%9A%A9%EC%84%B1-%EB%86%92%EC%9D%B4%EA%B8%B0/" rel="alternate" type="text/html" title="Kubernetes - Pod 불균형 없애고 가용성 높이기" /><published>2021-10-19T16:00:00+09:00</published> <updated>2021-10-19T16:00:00+09:00</updated> <id>https://wsscc2021.github.io/posts/Kubernetes-Pod-%EB%B6%88%EA%B7%A0%ED%98%95-%EC%97%86%EC%95%A0%EA%B3%A0-%EA%B0%80%EC%9A%A9%EC%84%B1-%EB%86%92%EC%9D%B4%EA%B8%B0/</id> <content src="https://wsscc2021.github.io/posts/Kubernetes-Pod-%EB%B6%88%EA%B7%A0%ED%98%95-%EC%97%86%EC%95%A0%EA%B3%A0-%EA%B0%80%EC%9A%A9%EC%84%B1-%EB%86%92%EC%9D%B4%EA%B8%B0/" /> <author> <name>D.G.Lee</name> </author> <category term="DevOps" /> <summary> Pod 불균형 파드를 생성할 때에 스케줄링에 아무런 제약을 주지 않으면 리소스 공간이 있는 노드에 무분별하게 스케줄링된다. 이러한 스케줄링 방식은 시스템 가용성의 허점을 줄 수 있다. 아래를 살펴보자. 서비스가 현재 트래픽을 견디기 위해서 4.0 CPU Core를 필요로 하고, 이를 위해서 2.0 CPU Core 를 가지는 파드를 4대 운영하고 있다고 가정해보자. 그리고, 파드를 생성할 때 스케줄링에 별다른 제약이 없다면, node-A의 리소스 공간이 충분하여 node-A에 3대의 파드가 스케줄링되고, node-B에 1대의 파드가 스케줄링된다. 물론 아무런 장애가 발생하지 않는다면, 이러한 시스템도 정상적으로 운영될 것이다. 하지만 node-A에 장애가 생기게 된다면 node-B에는 1대의 파... </summary> </entry> <entry><title>컨테이너 기술 이해하기</title><link href="https://wsscc2021.github.io/posts/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B8%B0%EC%88%A0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="컨테이너 기술 이해하기" /><published>2021-10-08T18:00:00+09:00</published> <updated>2021-10-20T16:38:25+09:00</updated> <id>https://wsscc2021.github.io/posts/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B8%B0%EC%88%A0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</id> <content src="https://wsscc2021.github.io/posts/%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88-%EA%B8%B0%EC%88%A0-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" /> <author> <name>D.G.Lee</name> </author> <category term="DevOps" /> <summary> Overview 이전 글에서 MSA(Micro Service Architecture) 를 이해하였습니다. 컨테이너는 MSA의 시대가 열리면서 굉장히 주목받게된 기술 중에 하나이기 때문에 연관지어 이해할 필요가 있습니다. MSA 에서는 하나의 큰 어플리케이션이 작은 단위의 서비스 여러개로 나뉘고, 각 서비스는 서로에게 영향을 주지않고 운영되어야 하기 때문에 서비스 수 만큼의 독립된 컴퓨터 시스템을 가져야합니다. 기존에는 하나의 컴퓨터 시스템이 필요했다면, MSA에서는 서비스 수 만큼의 여러 컴퓨터 시스템이 필요하게 된 것입니다. 그리고 대체로 서비스는 단위가 작지만, 서버로 운영되는 컴퓨터 리소스는 대체로 용량이 크기 때문에 하나의 컴퓨터 리소스로 하나의 컴퓨터 시스템을 운영하는 것이 비효율적이... </summary> </entry> <entry><title>Kubernetes - Healthcheck (liveness-probe, startup-probe, readiness-probe)</title><link href="https://wsscc2021.github.io/posts/Kubernetes-Healthcheck-(liveness-probe,-startup-probe,-readiness-probe)/" rel="alternate" type="text/html" title="Kubernetes - Healthcheck (liveness-probe, startup-probe, readiness-probe)" /><published>2021-10-07T20:30:00+09:00</published> <updated>2021-10-08T09:16:57+09:00</updated> <id>https://wsscc2021.github.io/posts/Kubernetes-Healthcheck-(liveness-probe,-startup-probe,-readiness-probe)/</id> <content src="https://wsscc2021.github.io/posts/Kubernetes-Healthcheck-(liveness-probe,-startup-probe,-readiness-probe)/" /> <author> <name>D.G.Lee</name> </author> <category term="DevOps" /> <summary> Overview Kubernetes에서는 pod 의 상태를 확인하기 위해서 liveness-probe, startup-probe, readiness-probe가 사용됩니다. 각각을 살펴보면서 어떻게 활용할지에 대한 고민을 해봅니다. (HTTP, TCP, Exec 3가지 타입의 probe가 존재하지만, 가장 많이 사용되는 HTTP probe 타입으로 진행합니다.) liveness probe liveness probe는 에러가 발생하여 요청을 처리할 수 없는 상태의 pod를 재시작하는 것에 사용됩니다. (Self-Healing) liveness probe는 healthcheck에 실패한 pod를 kill하고, 다시 시작합니다. livenessProbe: httpGet: path: /he... </summary> </entry> <entry><title>마이크로서비스 아키텍처 이해하기</title><link href="https://wsscc2021.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" rel="alternate" type="text/html" title="마이크로서비스 아키텍처 이해하기" /><published>2021-10-07T13:00:00+09:00</published> <updated>2021-10-12T08:08:56+09:00</updated> <id>https://wsscc2021.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/</id> <content src="https://wsscc2021.github.io/posts/%EB%A7%88%EC%9D%B4%ED%81%AC%EB%A1%9C%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0/" /> <author> <name>D.G.Lee</name> </author> <category term="DevOps" /> <summary> Overview 이번 글에서는 MSA가 무엇인지를 이해하고, 특징이 무엇인지, 어떤 활용 가치를 가지는 지에 대해서 이야기 해보겠습니다. MSA를 이해하기에 앞서서 MSA가 등장하고 주목받게된 이유에 대해서 설명하기 위해 기존에 사용되던 형태인 Monolithic Architecture에 대해서 살펴보겠습니다. Monolithic Architecture Monolithic Architecture는 어플리케이션을 구성하는 서비스(기능)들이 하나의 유닛으로 개발/배포/운영되는 형태입니다. 온라인 쇼핑몰 어플리케이션을 예를 들면 주문,계정관리,상품관리 등의 모든 기능을 하나의 Spring 앱으로 개발/배포/운영되는 것입니다. (*Spring 앱 내에서 MVC로 설계하고 기능을 나누어 개발하였더라... </summary> </entry> </feed>
